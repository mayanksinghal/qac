// Generated by CoffeeScript 1.3.3
(function() {
  var QAC;

  QAC = (function() {
    var GlobalInputHandle, TipHandle, WordTrie, defaultDict, globalInputHandle, log, logArea, renderOnInputArea, resetCharRegex, takeInput, tipHandle, wordTrie;

    logArea = null;

    tipHandle = null;

    defaultDict = [
      {
        type: 'store',
        sendUpdates: true,
        url: 'js/words.php?jsoncallback=?',
        sendUrl: 'js/words.php?op=add&jsoncallback=?',
        weight: 1
      }, {
        type: 'self',
        weight: 2
      }, {
        type: 'page',
        url: '/',
        weight: 3
      }
    ];

    wordTrie = null;

    globalInputHandle = null;

    resetCharRegex = /[~`!@#$%^&*()_\-=+\[\]{};:'"<>,./?\\|\s]/;

    TipHandle = (function() {
      var MaxRenderCount, allCandidates, highlightLength, offset, position, showTip, startOffset, tipArea;

      tipArea = null;

      startOffset = 0;

      MaxRenderCount = 10;

      allCandidates = null;

      highlightLength = 0;

      position = null;

      offset = null;

      showTip = function() {
        var attachCandidate, candidatesToShow, ele, renderCount, word, _i, _j, _len, _len1, _ref;
        attachCandidate = function(word) {
          var candidate;
          candidate = $("<span></span>").addClass("outer");
          candidate.html(word.substring(highlightLength));
          candidate.prepend($("<span></span>").addClass("highlight").html(word.substring(0, highlightLength)));
          return tipArea.find("div.inner").append(candidate);
        };
        tipArea.find("span").remove();
        renderCount = MaxRenderCount > allCandidates.length ? allCandidates.length : MaxRenderCount;
        candidatesToShow = allCandidates.slice(startOffset, startOffset + renderCount);
        if (startOffset + renderCount > allCandidates.length) {
          _ref = allCandidates.slice(0, startOffset + renderCount - allCandidates.length);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            ele = _ref[_i];
            candidatesToShow.push(ele);
          }
        }
        if (candidatesToShow.length === 0) {
          return false;
        }
        for (_j = 0, _len1 = candidatesToShow.length; _j < _len1; _j++) {
          word = candidatesToShow[_j];
          attachCandidate(word);
        }
        tipArea.css({
          left: offset.left + position.left,
          top: offset.top + position.top
        });
        tipArea.fadeIn(100);
        return candidatesToShow[0];
      };

      function TipHandle() {
        tipArea = $("<div></div>").addClass("qac_tip");
        tipArea.append($("<div></div>").addClass("inner"));
        $("body").append(tipArea);
      }

      TipHandle.prototype.hide = function() {
        return tipArea.fadeOut(50);
      };

      TipHandle.prototype.show = function(_words, _highlightLength, _pos, _offset) {
        startOffset = 0;
        allCandidates = _words;
        highlightLength = _highlightLength;
        position = _pos;
        offset = _offset;
        return showTip();
      };

      TipHandle.prototype.showNext = function() {
        startOffset += 1;
        if (startOffset === allCandidates.length) {
          startOffset = 0;
        }
        return showTip();
      };

      TipHandle.prototype.showPrevious = function() {
        startOffset -= 1;
        if (startOffset < 0) {
          startOffset = allCandidates.length - 1;
        }
        return showTip();
      };

      return TipHandle;

    })();

    log = function(msg, cls) {
      if (cls == null) {
        cls = "info";
      }
      if (logArea != null) {
        return logArea.prepend($("<tr></tr>").addClass(cls).append($("<td></td>").html(msg)));
      } else {
        if ((typeof console !== "undefined" && console !== null) && (console.log != null)) {
          return console.log(cls + ": " + msg);
        }
      }
    };

    WordTrie = (function() {
      var PingbackHandler, getTextFromHTML, loadDict, ping, trie;

      trie = null;

      ping = null;

      PingbackHandler = (function() {
        var pingObjs, sendPing;

        pingObjs = {};

        sendPing = function(i, word) {
          return;
          if (word != null) {
            pingNow(i, word);
            pingObjs[i].wordList.push(word);
            if (!pingObjs[i].isActive) {
              sendPing(i);
            }
            return;
          }
          pingObjs[i].isActive = true;
          $.ajax({
            url: pingObjs[i].url,
            dataType: 'json',
            data: pingObjs[i].wordList.concat([]),
            complete: function() {
              return pingObjs[i].isActive = false;
            },
            success: function(response) {
              log("" + response.count + " words pinged on <code>" + pingObjs[i].url + "</code>");
              if (pingObjs[i].wordList.length > 0) {
                return sendPing(i);
              }
            },
            error: function(response) {
              if (response.reason != null) {
                return log("<code>" + pingObjs[i].url + "</code> couldn't be pinged.								Reason: " + respose.reason);
              } else {
                return log("<code>" + pingObjs[i].url + "</code> couldn't be pinged.");
              }
            }
          });
          return pingObjs[i].wordList = [];
        };

        function PingbackHandler() {}

        PingbackHandler.prototype.addPingUrl = function(index, url) {
          return pingObjs[index] = {
            url: url,
            wordList: [],
            isActive: false
          };
        };

        PingbackHandler.prototype.ping = function(i, word) {
          return sendPing(i, word);
        };

        PingbackHandler.prototype.all = function(word) {
          var i, obj, _results;
          _results = [];
          for (i in pingObjs) {
            obj = pingObjs[i];
            _results.push(sendPing(i, word));
          }
          return _results;
        };

        return PingbackHandler;

      })();

      getTextFromHTML = function(html) {
        return $(html).text();
      };

      loadDict = function(dictInfo, dictIndex) {
        var createWordList, handleWordList;
        createWordList = function(htmlResponse) {
          var raw, retVal, text, w, _i, _len;
          if (htmlResponse != null) {
            text = getTextFromHTML(htmlResponse);
          } else {
            text = $("body").text();
          }
          retVal = [];
          raw = text.split(resetCharRegex);
          for (_i = 0, _len = raw.length; _i < _len; _i++) {
            w = raw[_i];
            if (w.length > 0) {
              retVal.push(w);
            }
          }
          return retVal;
        };
        handleWordList = function(wordList) {
          var addCount, handleWord, mergeCount, word, _i, _len;
          addCount = 0;
          mergeCount = 0;
          handleWord = function(word) {
            var obj;
            if (trie.containsKey(word)) {
              mergeCount += 1;
              obj = trie.get(word);
              obj.source.push(dictIndex);
              return trie.set(word, obj);
            } else {
              obj = {
                source: [dictIndex],
                val: dictInfo.weight
              };
              trie.add(word, obj);
              return addCount += 1;
            }
          };
          for (_i = 0, _len = wordList.length; _i < _len; _i++) {
            word = wordList[_i];
            handleWord(word);
          }
          return log("(" + addCount + " + " + mergeCount + ") words loaded from <code>" + dictInfo.url + "</code>");
        };
        if (!(dictInfo.type != null)) {
          dictInfo.type = "self";
        }
        if (dictInfo.type === "self") {
          dictInfo.url = location.href;
        }
        switch (dictInfo.type) {
          case "store":
            $.ajax({
              url: dictInfo.url,
              dataType: 'json',
              success: function(response) {
                return handleWordList(response);
              }
            });
            break;
          case "page":
            $.ajax({
              url: dictInfo.url,
              success: function(response) {
                return handleWordList(createWordList(response));
              }
            });
            break;
          case "self":
            handleWordList(createWordList());
        }
        if (dictInfo.sendUpdates) {
          return ping.addPingUrl(dictIndex, dictInfo.sendUrl);
        }
      };

      function WordTrie() {
        trie = new goog.structs.Trie();
        ping = new PingbackHandler();
      }

      WordTrie.prototype.loadDicts = function(dicts) {
        var dictInfo, i, _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = dicts.length; _i < _len; i = ++_i) {
          dictInfo = dicts[i];
          _results.push(loadDict(dictInfo, i));
        }
        return _results;
      };

      WordTrie.prototype.getCandidates = function(prefix) {
        var head, key, keys, pq, sortedKeys, _i, _len;
        keys = trie.getKeys(prefix);
        pq = new goog.structs.PriorityQueue();
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          pq.enqueue(0 - trie.get(key).val, key);
        }
        sortedKeys = [];
        while (typeof (head = pq.dequeue()) !== 'undefined') {
          sortedKeys.push(head);
        }
        return sortedKeys;
      };

      WordTrie.prototype.pingAsRequired = function(word) {};

      WordTrie.prototype.addIfNew = function(word) {
        if (trie.containsKey(word) || word.length === 0) {
          return;
        }
        log("Adding: " + word);
        trie.add(word, {
          source: [-1],
          val: 4
        });
        return ping.all(word);
      };

      return WordTrie;

    })();

    renderOnInputArea = function(inputArea, candidate, wordLength, caretPosStart, caretPosEnd) {
      var newVal, oldVal, partToRender;
      partToRender = candidate.substring(wordLength);
      oldVal = inputArea.val();
      if (!(caretPosEnd != null)) {
        caretPosEnd = caretPosStart;
      }
      newVal = "" + (oldVal.substring(0, caretPosStart)) + partToRender + (oldVal.substring(caretPosEnd));
      inputArea.val(newVal);
      return inputArea.caret({
        start: caretPosStart,
        end: partToRender.length + caretPosStart
      });
    };

    takeInput = function(inputArea) {
      var candidates, currentCandidate, pos, word;
      word = getCurrentWord(inputArea);
      pos = inputArea.caret();
      if (word.length === 0) {
        tipHandle.hide();
        return word;
      }
      candidates = wordTrie.getCandidates(word);
      currentCandidate = tipHandle.show(candidates, word.length, inputArea.getCaretPosition(), inputArea.offset());
      if (currentCandidate) {
        renderOnInputArea(inputArea, currentCandidate, word.length, pos.start);
      }
      return word;
    };

    GlobalInputHandle = (function() {
      var acceptSuggestion, doBackSpace, findAndRenderCandidates, getCurrentWord, globalDiable, globalEnable, inList, isActive, isGlobalDisabled, isKeyCharacters, isOtherModifierPressed, isPrintableCharacter, isResetCharacters, isShift, isShiftPressed, isSpecialType1, isTempDisabled, isToolTipDisabled, keys, onBlur, onFocus, onKeyDown, onKeyUp, qacIcon, renderIcon, renderOnEle, resetTempDefaults, showNext, showPrevious, tempDisable, tempEnable;

      isActive = false;

      isTempDisabled = false;

      isGlobalDisabled = false;

      isToolTipDisabled = false;

      qacIcon = null;

      isShiftPressed = false;

      isOtherModifierPressed = false;

      inList = function(v, l) {
        var hn, inL, li, _i, _len;
        inL = false;
        hn = function(li) {
          if (v === li) {
            return inL = true;
          }
        };
        for (_i = 0, _len = l.length; _i < _len; _i++) {
          li = l[_i];
          hn(li);
        }
        return inL;
      };

      getCurrentWord = function(inputArea, ignoreChar) {
        var position, resetPos, text;
        if (ignoreChar == null) {
          ignoreChar = false;
        }
        position = inputArea.caret().start;
        if (ignoreChar) {
          position -= 1;
        }
        text = inputArea.val().substring(0, position);
        resetPos = text.split("").reverse().join("").search(resetCharRegex);
        if (resetPos === -1) {
          return text;
        }
        resetPos = text.length - resetPos;
        if (resetPos === text.length) {
          return "";
        }
        return text.substring(resetPos);
      };

      keys = {
        tab: 9,
        space: 32,
        backspace: 8,
        enter: 13,
        escape: 27,
        up: 38,
        down: 40,
        shift: 16,
        ctrl: 17,
        alt: 18,
        window: 91,
        other_meta: 93,
        yet_another_meta: 224
      };

      isKeyCharacters = function(keyCode) {
        return (keyCode >= 48 && keyCode <= 90) || (keyCode >= 96 && keyCode <= 105);
      };

      isPrintableCharacter = function(keyCode) {
        var numbers;
        numbers = isShiftPressed && (keyCode >= 48 && keyCode <= 57) ? false : keyCode >= 48 && keyCode <= 57;
        return numbers || (keyCode >= 58 && keyCode <= 90) || (keyCode >= 96 && keyCode <= 111) || (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222);
      };

      isResetCharacters = function(keyCode) {
        return (isShiftPressed && (keyCode >= 48 && keyCode <= 57)) || inList(keyCode, [192, 189, 187, 219, 221, 220, 186, 222, 188, 190, 191, 111, 106, 109, 107, 110, 13, keys.space]);
      };

      isSpecialType1 = function(keyCode) {
        return keyCode === keys.backspace || keyCode === keys.space;
      };

      resetTempDefaults = function() {
        isActive = false;
        isTempDisabled = false;
        return tipHandle.hide();
      };

      tempDisable = function() {
        isActive = false;
        isTempDisabled = true;
        tipHandle.hide();
        return qacIcon.addClass("temp_disabled");
      };

      tempEnable = function() {
        isTempDisabled = false;
        return qacIcon.removeClass("temp_disabled");
      };

      globalDiable = function() {
        isActive = false;
        isGlobalDisabled = true;
        qacIcon.addClass("disabled");
        return tipHandle.hide();
      };

      globalEnable = function() {
        isGlobalDisabled = false;
        return qacIcon.removeClass("disabled");
      };

      renderIcon = function() {
        qacIcon = $("<div></div>").addClass("qac_icon");
        qacIcon.hover(function() {
          return qacIcon.toggleClass("hover");
        });
        qacIcon.click((function() {
          if (isGlobalDisabled) {
            return globalEnable();
          } else {
            return globalDiable();
          }
        }));
        return $('body').append(qacIcon);
      };

      renderOnEle = function(ele, partToRender, caretPosStart, caretPosEnd) {
        var newVal, oldVal;
        if (!(caretPosEnd != null)) {
          caretPosEnd = caretPosStart;
        }
        oldVal = ele.val();
        newVal = oldVal.substring(0, caretPosStart) + partToRender + oldVal.substring(caretPosEnd);
        return ele.val(newVal).caret({
          start: caretPosStart,
          end: partToRender.length + caretPosStart
        });
      };

      doBackSpace = function(ele) {
        var caretPos;
        caretPos = ele.caret();
        return renderOnEle(ele, "", caretPos.start - 1, caretPos.end);
      };

      findAndRenderCandidates = function(ele) {
        var candidates, currentWord;
        isActive = true;
        currentWord = getCurrentWord(ele);
        if ((currentWord.length > 0) && ((candidates = wordTrie.getCandidates(currentWord)).length > 0)) {
          tipHandle.show(candidates, currentWord.length, ele.getCaretPosition(), ele.offset());
          renderOnEle(ele, candidates[0].substring(currentWord.length), ele.caret().start, ele.caret().end);
        } else {
          isActive = false;
          tipHandle.hide();
        }
        return currentWord;
      };

      showPrevious = function(ele) {
        var caretPos, currentCandidate, currentWord;
        currentWord = getCurrentWord(ele);
        currentCandidate = tipHandle.showPrevious();
        if (currentCandidate) {
          caretPos = ele.caret();
          return renderOnEle(ele, currentCandidate.substring(currentWord.length), caretPos.start, caretPos.end);
        }
      };

      showNext = function(ele) {
        var caretPos, currentCandidate, currentWord;
        currentWord = getCurrentWord(ele);
        currentCandidate = tipHandle.showNext();
        if (currentCandidate) {
          caretPos = ele.caret();
          return renderOnEle(ele, currentCandidate.substring(currentWord.length), caretPos.start, caretPos.end);
        }
      };

      acceptSuggestion = function(ele) {
        var caretPos;
        caretPos = ele.caret();
        return renderOnEle(ele, "", caretPos.end, caretPos.end);
      };

      onFocus = function(ele, event) {
        qacIcon.css({
          top: ele.offset().top,
          left: ele.offset().left
        });
        return qacIcon.fadeIn(200);
      };

      onBlur = function(ele, event) {
        qacIcon.fadeOut(100);
        return resetTempDefaults();
      };

      isShift = false;

      onKeyDown = function(ele, event) {
        if (isGlobalDisabled) {

        } else if (event.keyCode === keys.shift && !isShift) {
          return isShiftPressed = true;
        } else if (inList(event.keyCode, [keys.ctrl, keys.alt, keys.window, keys.other_meta])) {
          isOtherModifierPressed = true;
          return tempDisable();
        } else if (isActive && event.keyCode === keys.backspace) {
          event.preventDefault();
          doBackSpace(ele);
          return findAndRenderCandidates(ele);
        } else if (isActive && event.keyCode === keys.up) {
          event.preventDefault();
          return showPrevious(ele);
        } else if (isActive && event.keyCode === keys.down) {
          event.preventDefault();
          return showNext(ele);
        } else if (!isTempDisabled && isActive && (event.keyCode === keys.tab || event.keyCode === keys.enter)) {
          return event.preventDefault();
        }
      };

      onKeyUp = function(ele, event) {
        var currentWord;
        if (event.keyCode === keys.shift) {
          isShiftPressed = false;
        }
        if (inList(event.keyCode, [keys.ctrl, keys.alt, keys.window, keys.other_meta])) {
          isOtherModifierPressed = false;
          tempEnable();
        }
        if (isOtherModifierPressed) {
          return;
        }
        if (event.keyCode === keys.escape) {
          if (isGlobalDisabled) {
            tempEnable();
            globalEnable();
          } else {
            if (isTempDisabled) {
              globalDiable();
            } else {
              tempDisable();
            }
          }
        }
        if (isGlobalDisabled) {

        } else if (event.keyCode === keys.backspace && isTempDisabled && getCurrentWord(ele).length === 0) {
          return tempEnable();
        } else if (!isTempDisabled && isKeyCharacters(event.keyCode)) {
          return currentWord = findAndRenderCandidates(ele);
        } else if (!isTempDisabled && isActive && (event.keyCode === keys.tab || event.keyCode === keys.enter)) {
          event.preventDefault();
          acceptSuggestion(ele);
          return tempDisable();
        } else if ((!isActive) && isResetCharacters(event.keyCode)) {
          return wordTrie.addIfNew(getCurrentWord(ele, true));
        } else if (isResetCharacters(event.keyCode)) {
          return resetTempDefaults();
        }
      };

      function GlobalInputHandle() {
        renderIcon();
      }

      GlobalInputHandle.prototype.addElement = function(eleSelector) {
        var ele;
        ele = $(eleSelector);
        ele.bind("keyup", function(event) {
          return onKeyUp($(this), event);
        });
        ele.bind("keydown", function(event) {
          return onKeyDown($(this), event);
        });
        ele.bind("focus", function(event) {
          return onFocus($(this), event);
        });
        return ele.bind("blur", function(event) {
          return onBlur($(this), event);
        });
      };

      return GlobalInputHandle;

    })();

    function QAC(logAreaSel, dictionaries) {
      if (dictionaries == null) {
        dictionaries = defaultDict;
      }
      if (logAreaSel != null) {
        logArea = $(logAreaSel);
        log("Debugging started");
      }
      wordTrie = new WordTrie();
      wordTrie.loadDicts(dictionaries);
      tipHandle = new TipHandle();
      globalInputHandle = new GlobalInputHandle();
    }

    QAC.prototype.listen = function(inputAreaSelector) {
      if (inputAreaSelector != null) {
        return globalInputHandle.addElement(inputAreaSelector);
      }
    };

    return QAC;

  })();

  window.QAC = QAC;

}).call(this);
